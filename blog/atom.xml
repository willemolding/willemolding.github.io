<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://willemolding.github.io/blog</id>
    <title>Willem Olding Blog</title>
    <updated>2023-09-21T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://willemolding.github.io/blog"/>
    <subtitle>Willem Olding Blog</subtitle>
    <icon>https://willemolding.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[On-Chain Dispute Games - Past, Present and Future]]></title>
        <id>dispute-games</id>
        <link href="https://willemolding.github.io/blog/dispute-games"/>
        <updated>2023-09-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A short survey of different strategies of resolving disputes on-chain]]></summary>
        <content type="html"><![CDATA[<p>One way to think of a blockchain is as a system for verifying provable statements to alter a global state. Examples of provable statements include:</p><ul><li>Proving you hold a private key corresponding to a public key by signing some data. This is how transactions are authorized to mutate the ledger.</li><li>A proof-of-work (PoW)</li><li>Proving you know the pre-image of a hash</li><li>Proving result of executing a known, deterministic program on known data. The blockchain executes the program itself to check the result</li><li>A SNARK proof of the result of executing a known program on (possibly unknown) data</li></ul><p>To verify a proof, the blockchain performs the verification computation inside its execution and this can result in changes to global state. Other on-chain applications can treat the result as if it is truth.</p><p>Some statements have a lovely property in that they are <em>succinct</em>. This means it is easier to verify them than it is to prove them (PoW, SNARK). Others take the same amount of work either way (deterministic arbitrary computation). </p><p>What you might have spotted from above is that some of these are in theory provable statements but they are impractical to prove on a blockchain. For example hashing an extremely large piece of data, or checking the result of a long and complex computation.</p><p>Dispute games are multi-party protocols that, under certain economic conditions, can allow a blockchain to be convinced of a statement while only having to execute a small part of a computation when disputes arise.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="one-step-fraud-proving">One-step Fraud Proving<a class="hash-link" href="#one-step-fraud-proving" title="Direct link to heading">​</a></h2><p>For statements that could be proven on-chain there is an elegant solution that can avoid expensive verification costs. In a one-step fraud proof Ashley submits a statement on-chain (e.g. the result of this computation is X) along with a bond. The bond should be greater than the expected gas cost of having the chain verify the proof.</p><p>The statement is considered pending by the chain for a length of time known as the challenge period. During this time anyone (Bellamy) can pay the gas and force the chain to perform the check in full. This will then determine if Ashley was indeed correct and update the state accordingly. If Ashley is proven to be wrong their bond is slashed and given to Bellamy.</p><p>Importantly, if no one challenges Ashley during the challenge period it is safe to assume the statement is true under the assumption that there is at least one observer who would have proven Ashely false if they could.</p><p>This approach is great for on-going protocols like rollups where it is important to keep the running cost low. It is relatively simple in its implementation and can be permissionless. </p><p>This design was used by the early versions of Optimism such that the rollup state transition was only computed on L1 in the case of a dispute. Another clever application is in the <a href="https://near.org/blog/eth-near-rainbow-bridge" target="_blank" rel="noopener noreferrer" title="Eth-NEAR Rainbow Bridge">Eth-NEAR Rainbow Bridge</a> where one-step fraud proofs are used to avoid performing expensive Ed25519 signature checks on Ethereum under regular operation. In recent months some projects such as <a href="https://fuel-labs.ghost.io/introducing-hybrid-proving/" target="_blank" rel="noopener noreferrer" title="Fuel Labs - Hybrid proving">Fuel</a> have proposed using on-step fraud proofs to avoid performing expensive SNARK verification unless there is a dispute.</p><p>The downside to one-step proofs is they are not applicable in every case. It must be possible to fall back to executing the verification on-chain. Some types of computation are simply too large or require too much data for this to be feasible. What can be done in this case?</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-party-bisection-dispute-games">2-party bisection dispute games<a class="hash-link" href="#2-party-bisection-dispute-games" title="Direct link to heading">​</a></h2><p>The <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf" target="_blank" rel="noopener noreferrer" title="Arbitrum: Scalable, private smart contracts">Arbitrum paper</a> first popularized bisection dispute games in the blockchain space. To understand a bisection game you first need to understand emulators and the computation trace. </p><p>A program can be expressed as a sequence of instructions to be executed on a processor. This processor also has registers and/or memory to store state.</p><p>Executing the program and recording the registers+memory at after each instruction is called an execution trace. This trace may be much longer than the original program as instructions may branch or loop. For a program that terminates this execution trace can be considered a very verbose proof of the final state. A program that knows how to execute all the possible instructions and update the state accordingly (an emulator) can verify this proof.</p><p>A program trace for any non-trivial program is absurdly huge, but it can be compressed using two clever tricks.</p><p>The first is that the full CPU+memory state need not be included at each step. Instead a commitment of the state (e.g. Merkle root) can be recorded instead.</p><p>The second applies when there are two conflicting parties in dispute about the result of executing a program. A two-party protocol can be used to reduce the trace down to the first instruction that the parties disagree upon the result of. A third trusted arbitrator (usually a blockchain runtime) can then execute only a single instruction in the trace resolve a dispute over an entire program.</p><p>This last trick of framing the dispute as being between two parties allows proving faults in programs in a number of steps that is logarithmic in the length of the trace, followed by the execution of a single instruction. This is incredibly powerful and has been developed by Arbitrum and the Optimism Bedrock prototype for proving rollup state transitions, along with Cartesi for proving arbitrary computations on-chain.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="problems">Problems<a class="hash-link" href="#problems" title="Direct link to heading">​</a></h3><p>The problem with this approach as described is that once two players are engaged in a dispute they must both remain live in order to resolve it. There is also no way to ensure that both participants are honest so it must be possible for multiple disputes to be open on a single claim at once for the honest minority assumption to hold.</p><p>A malicious challenger may open many dispute games on a single assertion and although they will lose their bond if they have more available funds than the defender they can eventually prevent them from being able to participate. I have written about this issue in <a href="https://willemolding.github.io/blog/attacks-permissionless-fraud" target="_blank" rel="noopener noreferrer" title="Some Attacks on Optimistic Systems">another article</a>.</p><p>The usual solution to this is to limit who can participate in dispute games. This is the approach used by Arbitrum and the Optimism Bedrock prototype. This compromise places these dispute game systems in an in-between trusted federation and fully permissionless dispute games.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="permissionless-bisection-dispute-games">Permissionless Bisection Dispute Games<a class="hash-link" href="#permissionless-bisection-dispute-games" title="Direct link to heading">​</a></h2><p>So can bisection style dispute games be made fully permissionless? A recent <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf" target="_blank" rel="noopener noreferrer" title="Arbitrum: Scalable, private smart contracts">paper by Nehab and Teixeira</a> proposes a modification to the dispute games where the participants must submit a vector commitment to the entire execution trace before the game begins. Once this has been done the game becomes permissionless as anyone can submit a step along with its inclusion proof.</p><p>This is an excellent solution however it has a major drawback. Execution traces are incredibly large, commonly several trillion instructions. Producing a merkle tree and associated proofs for such a long vector is prohibitive in most cases. The authors solution to this is to split the trace into stages and run </p><p>More recently Optimism has proposed <a href="https://www.youtube.com/watch?v=GaLm4iXOtOo&amp;t=1392s&amp;" target="_blank" rel="noopener noreferrer" title="Keys in Mordor Summit: Dispute Games">another design</a> which structures dispute game is structured as an n-degree tree rather than a binary tree. This allows other participants to fork off an existing dispute game when they believe participants to be fraudulent. </p><p>Bond is added incrementally at each step of the tree allowing permissionless participation. Once a game has concluded the player who asserted correctly against any branch that has been proven false can collect the bond on each of those nodes in the tree.</p><p>This design gives the best of both worlds allowing permissionless participation without needing to compute trace commitments. This is at the cost of increased complexity in implementation.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">​</a></h2><p>Dispute games are conceptually simple but designing them to be permissionless is much more challenging. Despite dispute games being proposed for use in blockchain systems more than 5 years ago, and claiming to be permissionless, there has not been a single permissionless dispute game used in production.</p><p>Optimism has made excellent progress in the last year design dispute games that can be safe and permissionless and these will hopefully be deployed in production in the near future.</p>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="l2" term="l2"/>
        <category label="interoperability" term="interoperability"/>
        <category label="game-theory" term="game-theory"/>
        <category label="p2p" term="p2p"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Some Attacks on Optimistic Systems]]></title>
        <id>attacks-permissionless-fraud</id>
        <link href="https://willemolding.github.io/blog/attacks-permissionless-fraud"/>
        <updated>2023-01-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In theory optimistic systems promise an honest minority assumption. Any actor can watch the state of the system progress and report fraud by challenging a particular state transition. This comes with the guarantee that they will always win a challenge game against an invalid state transition.]]></summary>
        <content type="html"><![CDATA[<p>In theory optimistic systems promise an honest minority assumption. Any actor can watch the state of the system progress and report fraud by challenging a particular state transition. This comes with the guarantee that they will always win a challenge game against an invalid state transition.</p><p>In practice though many of the optimistic rollups in production do not currently have this property. In Arbitrum for example the ability to challenge state transitions is limited to a permissioned validator set<sup id="fnref-1-d304be"><a href="#fn-1-d304be" class="footnote-ref">1</a></sup>. </p><p>I spent some time thinking about some potential attacks against permissionless optimistic systems and, at least for the model system I considered, it appears the honest minority assumption comes with some strings attached when real world considerations such as gas costs come into play.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="model-system">Model System<a class="hash-link" href="#model-system" title="Direct link to heading">​</a></h2><p>Lets consider an abstracted optimistic system. This is not a rollup but rather a general iterative computation without inputs. Each state can be transitioned to the next state by executing the state transition function. </p><p>You could consider such a system similar to a programming loop with the state being the loop variables and  for each execution of the loop code the hash of the new loop state is submitted on-chain. </p><p>The challenge game itself has the following properties:</p><ul><li>Anyone can submit a new state commitment at a given sequence number (permissionless updates). This requires including a bond <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span></li><li>The first state commitment to have no open challenges after the finalization period, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{final}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em">f</span><span class="mord mathnormal mtight">ina</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span></span>, becomes finalized. Other submissions for the same sequence number are discarded and their bonds slashed.</li><li>Anyone can challenge an update that has not finalized (permissionless challenges). This also requires submitting a bond <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span>. The submitter and the challenger are now in a challenge game.</li><li>No new challenges can be submitted after <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{final}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em">f</span><span class="mord mathnormal mtight">ina</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span></span>. This prevents stalling attacks.</li><li>Any number of challenges can be opened on an update at once. This is required to ensure the honest minority assumption. If only a limited number of challenges are allowed then dishonest challengers could occupy all the slots.</li><li>The challenge game is a 2-party interactive game and requires on-chain submissions by both the defender (formerly submitter) and challenger. The gas cost for the defender is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">g_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> and for the challenger is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">g_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>. Each participant has time to respond <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{chal}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">ha</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>. </li><li>The winner of a challenge game receives half of the losers bond. The remainder of the loser bond is burnt.</li></ul><p>Lets also define some properties of the host chain:</p><ul><li>Each block has a gas limit <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">G</span></span></span></span></span></li><li>The block time is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{block}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">oc</span><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></li><li>A stable gas price of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">p</span></span></span></span></span></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="first-attack---challenger-dos">First Attack - Challenger DoS<a class="hash-link" href="#first-attack---challenger-dos" title="Direct link to heading">​</a></h2><p>This one is nothing new but will serve as a good first example using our model.</p><p>For this attack a malicious submitter submits an invalid state transition. They then prevent any challenger from challenging them by purchasing enough blockspace that the challenge transaction cannot fit for every block in the finalization period <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{final}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em">f</span><span class="mord mathnormal mtight">ina</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span></span>. The cost of this attack is</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>=</mo><mo stretchy="false">(</mo><mi>G</mi><mo>−</mo><msub><mi>g</mi><mi>c</mi></msub><mo stretchy="false">)</mo><mfrac><msub><mi>T</mi><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub><msub><mi>t</mi><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow></msub></mfrac><mi>p</mi></mrow><annotation encoding="application/x-tex">c = (G - g_c) \frac{T_{final}}{t_{block}} p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">oc</span><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em">f</span><span class="mord mathnormal mtight">ina</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">p</span></span></span></span></span></div><p>It can be seen that the only system specific parameters this depends on is the finalization time and the gas cost of a challenge response. Since the gas cost is usually fixed this attack is typically protected against by using a very large finalization time (e.g. 7 days).</p><p>The finalization time should be selected such that the cost of executing the attack exceeds the exploitable value ever expected to be held in the system.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="second-attack---challenge-flooding">Second Attack - Challenge Flooding<a class="hash-link" href="#second-attack---challenge-flooding" title="Direct link to heading">​</a></h2><p>This is an attack on an honest submitter. It is designed to steal their stake and delay finalization of the system.</p><p>It works by a malicious challenger submitting many (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span>) challenges on a single valid submission. The defender must respond to all of these challenges in order to defend their bond. The attack succeeds if the defender does not have sufficient funds to pay the gas to respond to all these challenges. Because the challenges are overlapping the defender cannot use the winnings from one to pay the gas for the others <sup id="fnref-2-d304be"><a href="#fn-2-d304be" class="footnote-ref">2</a></sup>.</p><p>The cost of this attack to the challenger depends on if it succeeds or fails. If it succeeds the challenger receives the defenders bond and prevents the update from finalizing. If it succeeds the cost is</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>=</mo><mi>N</mi><mi>p</mi><msub><mi>g</mi><mi>c</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">c = N p g_{c}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Np</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></div><p>If it fails the cost to the challenger is</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>=</mo><mi>N</mi><mo stretchy="false">(</mo><mi>B</mi><mo>+</mo><mi>p</mi><msub><mi>g</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c = N (B + p g_{d})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></div><p>and the defender wins <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>N</mi><mi>B</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N B}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">NB</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>. There is also a possibility of partial success where the defender can take some of the challenges but not others.</p><p>The conditions for this attack to be possible require an attacker with vastly more funds than the defender. The capital required to conduct this attack is</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>C</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow></msub><mo>=</mo><mi>N</mi><mo stretchy="false">(</mo><mi>B</mi><mo>+</mo><mi>p</mi><msub><mi>g</mi><mi>c</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_{attack} = N (B +p g_{c})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></div><p>and to defend against it is</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>C</mi><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub><mo>=</mo><mi>N</mi><mi>p</mi><msub><mi>g</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">C_{defend} = N p g_{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.10764em">f</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Np</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></div><p>and so to successfully conduct this attack requires an attacker with more funds than the defender by a factor of</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>B</mi><mo>+</mo><mi>p</mi><msub><mi>g</mi><mi>c</mi></msub></mrow><mrow><mi>p</mi><msub><mi>g</mi><mi>d</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{B + p g_{c}}{p g_d}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2408em;vertical-align:-0.8804em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></div><p>The implications for this are quite significant. If we consider the existence of mega-whales (like Coinbase). These actors could successfully conduct this attack at a very low cost on almost any submitter. By doing this repeatedly they can prevent any valid updates from being accepted and stall the system. </p><p>If we assume the gas costs cannot be changed the only way to mitigate this attack is to increase the bond size. With a sufficiently large bond relative to the defender gas cost this simultaneously limits which actors are able to make this attack while also limiting the accounts that can participate at all.</p><p>From this I conclude that for the described system the unbounded honest minority assumption does not hold. It should be reduced to an honest minority in the set of accounts with funds within a factor of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>p</mi><msub><mi>g</mi><mi>d</mi></msub></mrow><mrow><mi>B</mi><mo>+</mo><mi>p</mi><msub><mi>g</mi><mi>c</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{p g_d}{B+ p g_{c}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2286em;vertical-align:-0.4811em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">p</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.4461em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> of the largest gas token holder.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="looking-forward">Looking Forward<a class="hash-link" href="#looking-forward" title="Direct link to heading">​</a></h2><p>A recent article <sup id="fnref-3-d304be"><a href="#fn-3-d304be" class="footnote-ref">3</a></sup> was published (after I wrote this blog post!) that proposes a modification to the interactive game that could allow honest actors to band together and share the gas costs. See my next article for how this could be used to protect against the challenge flooding attack.</p><div class="footnotes"><hr><ol><li id="fn-1-d304be"><a href="https://l2beat.com/scaling/projects/arbitrum/" target="_blank" rel="noopener noreferrer">https://l2beat.com/scaling/projects/arbitrum/</a><a href="#fnref-1-d304be" class="footnote-backref">↩</a></li><li id="fn-2-d304be">At first glance one might think that the submitter could use the reward from one challenge game to pay the gas of the next one. This would be true if the challenge game was single-step (e.g. non-interactive) however the additional timeout period introduced by the interactive game means that the defender must wait to receive their half of the challengers bond and in this time they must respond to the other challenges or risk losing the interactive game through a timeout.<a href="#fnref-2-d304be" class="footnote-backref">↩</a></li><li id="fn-3-d304be"><a href="https://arxiv.org/pdf/2212.12439.pdf" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/2212.12439.pdf</a><a href="#fnref-3-d304be" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="fault-proofs" term="fault-proofs"/>
        <category label="rollups" term="rollups"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[On the feasibility of a Fault-proof Based Blockchain Bridge]]></title>
        <id>feasibility-fault-proof-bridges</id>
        <link href="https://willemolding.github.io/blog/feasibility-fault-proof-bridges"/>
        <updated>2022-11-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[For the hackathon at EthBogota the ChainSafe team developed a new bridge prototype we called Zipline. This bridge uses fault proofs, the technology behind optimistic rollups, to construct a bridge. But is this actually a good idea? This article investigates some potential issues but also some paths forward to a practical version of such a bridge construction.]]></summary>
        <content type="html"><![CDATA[<p>For the hackathon at EthBogota the ChainSafe team developed a new bridge prototype we called <a href="https://ethglobal.com/showcase/zipline-05w8k" target="_blank" rel="noopener noreferrer">Zipline</a>. This bridge uses fault proofs, the technology behind optimistic rollups, to construct a bridge. But is this actually a good idea? This article investigates some potential issues but also some paths forward to a practical version of such a bridge construction.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview">Overview<a class="hash-link" href="#overview" title="Direct link to heading">​</a></h2><p>Our project, like all great hackathon entries, is a bit of a Frankenstein. Inspired by the work on ZK bridges by Succinct Labs<sup id="fnref-1-096185"><a href="#fn-1-096185" class="footnote-ref">1</a></sup>, it uses the fault proof code from Optimism Cannon<sup id="fnref-2-096185"><a href="#fn-2-096185" class="footnote-ref">2</a></sup> and the Eth2 light client code from Snowbridge<sup id="fnref-3-096185"><a href="#fn-3-096185" class="footnote-ref">3</a></sup> to build a trustless block header relay for Gasper based chains (e.g. Ethereum and Gnosis Chain) to EVM chains.</p><p>The logic is fairly straightforward. The Altair hard-fork adds a light-client protocol to the beacon chain that allows resource constrained devices to trustlessly follow along with minimal communication and computational effort. Even this lightweight protocol is too expensive to execute within an EVM runtime and so we use fault proofs to allow off-chain execution of the light client protocol with on-chain settlement.</p><p>In the final Zipline protocol anyone can submit sync updates along with a sizeable bond. These updates have a challenge period during which anyone can dispute their validity and trigger the dispute resolution game (by also submitting a bond). This game uses bisection of the execution trace to resolve the instruction where fraud may have taken place. The isolated instruction is executed by the chain as the final judgement for if there was fraud or not.</p><p>It works exactly like fault-proof based rollups (e.g. Optimism, Arbitrum) but instead of executing transactions it is validating the light-client protocol of another chain.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="on-chain-requirements">On-chain Requirements<a class="hash-link" href="#on-chain-requirements" title="Direct link to heading">​</a></h2><p>In Zipline each sync period requires the following data to update:</p><ul><li>Attested block header hash</li><li>Aggregate BLS committee signature and participation bitfield</li><li>Next period sync committee (512 public keys)</li><li>Merkle proof of new committee</li></ul><p>Given an accepted prior committee the state transition function combines a subset of the committee keys to produce an aggregate public key to verify the attested block header (this is the main computation). It also needs to verify that the proposed new committee is correct. Since this is stored in the state this can be checked by verifying a Merkle state proof. The combined update ends up being around 25KB. </p><p>To make this data available to the provable execution we are using a technique from Cannon called the Pre-image Oracle. This allows the code running in a provable execution context to request any data by its hash. This seems slightly magical but the reason it works is that the provable execution can essentially freeze until this data has been provided to it. If the data (pre-image) cannot be provided then the challenge game cannot continue and fraud cannot be proven.</p><p>In our original design we went to great lengths to ensure that:</p><ol><li>The sync update data is always available</li><li>The code cannot request a hash which has no available pre-image</li></ol><p>We did this by requiring that the entire sync update message is submitted to the destination chain in calldata for each update. It is then hashed by the runtime and this hash inserted into the memory trie for the provable execution. Later on the provable execution code could use this hash to request the full data using the pre-image oracle.</p><p>The downside to this approach is gas costs. Mostly from calldata alone the cost to make each update is around 300k gas. Not impractically expensive but not cheap either. Especially considering the bridge must pay this every 27 hours for as long as it wants to run.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="proposed-improvement">Proposed Improvement<a class="hash-link" href="#proposed-improvement" title="Direct link to heading">​</a></h3><p>Later we had the insight that for a header relay it is acceptable to rely on the origin chain to provide the data availability. This still leaves the issue of block relayers who might submit garbage hashes for which there is no available pre-image and which therefore cannot be proven as fraud.</p><p>Our solution to this borrows an idea from state channels. It essentially adds a new kind of challenge, a pre-image challenge. A relayer submits only the hash of sync update data. If a watcher is unable to find the corresponding pre-image (and is therefore unable to check if the computation is valid) they can issue a pre-image challenge. The original relayer must then submit the pre-image on-chain within a given time period or have their bond slashed and issued to the challenger, the same penalty as fraud. The challenge should also be bonded to prevent griefing of the relayer.</p><p>Since the only valid sync updates are produced by another blockchain there are good guarantees that this data will be available. Submitting anything other than valid updates is fraud so a challenger can be certain of their own correctness before initiating a challenge.</p><p>In the happy case this reduces the calldata requirements down to a single hash making Zipline incredibly cheap to run.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="light-client-protocol---is-it-suitable">Light client Protocol - Is it suitable?<a class="hash-link" href="#light-client-protocol---is-it-suitable" title="Direct link to heading">​</a></h2><p>One strong assumption in the design is that the light-client protocol is suitable for these kinds of applications. At first glance it appears so but in reality it was made for quite a different purpose.</p><p>In the light-client protocol a subset of 512 validators known as the sync committee is selected to attest to the finalized block headers in their sync period (256 epochs). Every sync period this committee is rotated out and replaced with a new random committee. Committee members know one sync period in advance that they have been chosen.</p><p>The members of the sync committee are eligible for additional rewards for consistent signing of all the headers in their period. There are currently no penalties for sync committee misbehavior (equivocation or signing unfinalized blocks) other than missed rewards.</p><p>The strength of the light-client protocol is it does not require storing of the entire validator set (currently hundreds of thousands of addresses). The committee rotation can be verified with a few Merkle proofs and a previously validated block. It also significantly reduces the number of signatures that must be aggregated and validated to check block finality. This is perfect for mobile or browser devices that need to verify state or transactions in the chain.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="an-attack-on-a-light-client-bridge">An attack on a light-client bridge<a class="hash-link" href="#an-attack-on-a-light-client-bridge" title="Direct link to heading">​</a></h3><p>If 2/3 of a sync committee could collude it would be trivial for them to sign a fraudulent block header which by definition would be accepted by Zipline. According to the current light-client protocol they would not even be penalized for doing so. </p><p>Coordinating such an attack could be quite simple. Firstly there is a long time (2 sync periods or 54 hours) during which the nodes could coordinate. One could imagine a contract on the bridge destination chain that guarantees any colluding member of the committee receives a share of the value extracted from the bridge. Once the exploitable value reaches a certain threshold collusion would be an inevitability.</p><p>Even if the sync committee could be slashed for misbehavior collusion could still be worth it if the bridge could be hacked for more than the total slashable (32 <em> 512 </em> 2/3 = ~11k Eth). With bridges consistently being hacked for value far exceeding this could be real threat for light-client based bridges.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="switching-to-full-consensus">Switching to Full Consensus<a class="hash-link" href="#switching-to-full-consensus" title="Direct link to heading">​</a></h2><p>With the improvements suggested in the previous section there is actually nothing preventing Zipline from following the full Gasper consensus protocol rather than the light client. This requires more complexity in the state and inputs - the off-chain state must keep track of the entire validator set and the validators that enter/exit each epoch. It would also require aggregating a much larger verification key (1/32 of the full validator set, about 3k keys at the time of writing) to verify the finality of each block.</p><p>That aside in the happy case the on-chain storage and execution cost remains the same. The main difference is that this would require receiving an update for every epoch rather than every sync period so the required rate of updates is 256 times faster. The protocol must receive one update per epoch in order to follow the chain.</p><p>There is no doubt that this is the way forward in creating a secure bridge protocol based on Zipline. Such a bridge would inherit the economic security properties of the beacon chain (1/3 of all stake must be slashed to revert a finalized block). </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="fault-proof-delays">Fault Proof Delays<a class="hash-link" href="#fault-proof-delays" title="Direct link to heading">​</a></h2><p>Assuming that the consensus protocol is secure, Zipline still has the same issue that other fault-proof based systems have - the challenge period delay.</p><p>Prior to an update being accepted it must have a period during which any honest actor can observe fraud and initiate the challenge game. The question of how long this period must be is an interesting one. It must be sufficiently long to allow for:</p><ol><li>Off-chain actors to perform the computation for themselves to verify its correctness</li><li>A challenger to have a transaction included showing fraud has occurred</li></ol><p>The first point is less impactful overall as the computation for Zipline can be done in just a few seconds. Far more important is the second point. When attacking targets with potentially large payoffs (e.g. a bridge) it may be economically worthwhile for the attacker to purchase all blockspace for the duration of the challenge period, effectively censoring any transactions that are trying to prove fraud. The challenge period should therefore be set such that the cost of performing such a censoring attack is greater than the potential gains.</p><p>It is difficult to design the period length since it depends on so many extraneous factors: the gas price, exploitable value in the bridge/rollup, chain congestion etc. This is why most fraud-proof based system adopt the arbitrary, but safe, period of 7 days. </p><p>The question of if this is too long to wait for a bridge I think depends on the application. For traders chasing DeFi arbitrage opportunities it is almost certainly unacceptable, however, for being a gateway by which large volumes of wrapped ether are bridged to other chains it could be perfect.</p><p>Zipline also inherits the property other optimistic rollups have that allow for fast exits. Any off-chain observer can know if they system is committing fraud or not, even if the chain doesn't know yet. This makes it possible for liquidity providers to front funds to users of the bridge with the knowledge that they will inevitably receive their own wrapped tokens within 7 days with zero additional risk. A token bridge based on this protocol is likely the way forward for fraud-proof based bridges however it does not help with transferring non-fungible assets or generic message passing.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="for-the-future">For the Future<a class="hash-link" href="#for-the-future" title="Direct link to heading">​</a></h2><p>For Zipline to be safe and feasible it needs to make the switch to following the full consensus protocol rather than the light-client. This should come with minimal extra cost in the happy case as all of the computation and data remains off-chain. It does require much more frequent updates however (once per epoch rather than once per sync period). </p><p>Given this and the fast-exit strategy it should be possible to develop a cheap and user friendly token bridge based off of the Zipline block header relay. NFT and arbitrary message passing applications would still have to wait a full challenge period.</p><p>It would also be worth investigating how it could work for consensus protocols other than Gasper. Other popular BFT finality algorithms such as Tendermint and GRANDPA would be excellent candidates.</p><div class="footnotes"><hr><ol><li id="fn-1-096185"><a href="https://arxiv.org/abs/2210.00264" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2210.00264</a><a href="#fnref-1-096185" class="footnote-backref">↩</a></li><li id="fn-2-096185"><a href="https://github.com/ethereum-optimism/cannon" target="_blank" rel="noopener noreferrer">https://github.com/ethereum-optimism/cannon</a><a href="#fnref-2-096185" class="footnote-backref">↩</a></li><li id="fn-3-096185"><a href="https://github.com/Snowfork/snowbridge" target="_blank" rel="noopener noreferrer">https://github.com/Snowfork/snowbridge</a><a href="#fnref-3-096185" class="footnote-backref">↩</a></li></ol></div>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="bridges" term="bridges"/>
        <category label="provable computation" term="provable computation"/>
        <category label="fraud-proofs" term="fraud-proofs"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zipline Lightning Talk at Gnosis Builders (Video)]]></title>
        <id>zipline-lightning</id>
        <link href="https://willemolding.github.io/blog/zipline-lightning"/>
        <updated>2022-10-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A lightning talk by Myself, Eric Tu and Cayman Nava on our project Zipline. From Evening With Gnosis Chain side event at Devcon Bogota 2022.]]></summary>
        <content type="html"><![CDATA[<p>A lightning talk by Myself, Eric Tu and Cayman Nava on our project Zipline. From Evening With Gnosis Chain side event at Devcon Bogota 2022.</p><iframe width="560" height="315" src="https://www.youtube.com/embed/KkW4hLHdjrg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="bridges" term="bridges"/>
        <category label="provable computation" term="provable computation"/>
        <category label="fraud-proofs" term="fraud-proofs"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is a Pre-image Oracle and why is it awesome?]]></title>
        <id>preimge-oracle</id>
        <link href="https://willemolding.github.io/blog/preimge-oracle"/>
        <updated>2022-10-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A pre-image oracle is a way to lookup any piece of data (pre-image) by its hash. While this sounds impossible (and in the general case is) it is possible to write code assuming such a thing exists if it operates in a context where execution cannot continue unless the pre-image is provided by an external party.]]></summary>
        <content type="html"><![CDATA[<p>A pre-image oracle is a way to lookup any piece of data (pre-image) by its hash. While this sounds impossible (and in the general case is) it is possible to write code assuming such a thing exists if it operates in a context where execution cannot continue unless the pre-image is provided by an external party.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cannon-overview">Cannon Overview<a class="hash-link" href="#cannon-overview" title="Direct link to heading">​</a></h2><p>At a high level Optimism Cannon works by compiling some computation to the MIPS instruction set (the instruction set itself isn't important, this was just the one they picked). This computation takes some input and produces some output.</p><p>A full proof of a computation could be considered as the <em>trace</em> of the execution of this code. That is the snapshot of the memory + registers (state) after the execution of each opcode from some initial state.</p><p>Proving fraud in a computation can be reduced to finding two adjacent states in the trace where both parties agree on the former state but disagree on the latter. The transition between these states can be verified by executing a single MIPS opcode to verify who is correct. This is small enough for a blockchain to execute and act as the final arbitrator.</p><p>Since the state may be large we don't want to submit the whole thing on-chain. Each snapshot can be turned into a Merkle tree and only the root hash posted on-chain. Since they are merklized it is enough just to submit the roots and additionally provide proofs for:</p><ul><li>The opcode.</li><li>Any memory or registers the opcode reads from.</li></ul><p>These can be posted on-chain by either party and one of them is always incentivised to do so (the correct one).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-about-external-data">What about external data?<a class="hash-link" href="#what-about-external-data" title="Direct link to heading">​</a></h2><p>This is where the magic of the pre-image oracle comes in. Conceptually a pre-image oracle is a magic device that can return a piece of data given its hash. You can think of this as similar to how an IPFS PID is uniquely generated from data and can be used to retrieve the data from the network. <strong>Importantly, you can always check if the oracle is lying by hashing the provided data and ensuring it matches the hash you requested.</strong></p><p>In Cannon the proving code can pretend that such an oracle exists. It works as follows:</p><ul><li>The code places the hash of the data it wishes to access in a special memory slot</li><li>The host environment will then magically, and instantly, place the pre-image of this hash in another designated memory range</li></ul><p>From the code's perspective it has the ability to retrieve any data in existance given its hash. How is this possible!? </p><p>This can be seen in the <a href="https://github.com/ethereum-optimism/cannon/blob/dfac3fb2e09bb974e77e6563a64d898d049a2a90/contracts/MIPSMemory.sol#L201" target="_blank" rel="noopener noreferrer">code for reading the MIPS memory</a>. It checks if the program is reading from the pre-defined pre-image oracle range <code>[0x31000000, 0x32000000]</code> and if so it checks that the hash of the data matches the hash in the hash stored in the special location (<code>0x30001000</code>).</p><p>It works because the host environment will simply not continue to execute if the pre-image is not provided by some actor off-chain. Since the case where the pre-image is not provided can never exist, the code can live in the happy reality where it always does.</p><p>This has an important implication:</p><ul><li><strong>If an execution requests the pre-image of a hash where the pre-image is not available then a fraud proof can never be completed.</strong> Special care must be taken to ensure this cannot happen by ensuring the data is available in the history of the host chain (including calldata). </li></ul><p>But also an amazing upside:</p><ul><li><strong>Verifyable computation code can access any data in the host chain history or state including anything submitted in calldata!</strong></li></ul>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="bridges" term="bridges"/>
        <category label="provable computation" term="provable computation"/>
        <category label="fraud-proofs" term="fraud-proofs"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Right now there is no such thing as web3 gaming (Opinion)]]></title>
        <id>issues-with-gaming</id>
        <link href="https://willemolding.github.io/blog/issues-with-gaming"/>
        <updated>2022-04-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I'd like to make the argument that web3 in its most idealistic form and blockchain gaming in its popular current form are fundamentally incompatible with each other.]]></summary>
        <content type="html"><![CDATA[<p>I'd like to make the argument that web3 in its most idealistic form and blockchain gaming in its popular current form are fundamentally incompatible with each other.&nbsp;</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="lets-agree-onweb3">Lets agree on&nbsp;web3<a class="hash-link" href="#lets-agree-onweb3" title="Direct link to heading">​</a></h2><p>Before proceeding it is important to define exactly what we mean by web3. It is a notoriously difficult concept to pin down and it seems to mean various things in different contexts. In popular usage the term web3 appears to mean 'uses a blockchain' but lets take that out of the picture. Fundamentally most web3 idealists will claim a perfect World-Wide-Web-3.0  would provide:</p><ul><li>Control and Sovereignty   -  Users retain full control over their own data and can control how it is used. Access to protocols is not regulated by anyone.</li><li>Choice  -  Users are free to move between protocols and platforms and are also free to modify existing ones to better suit their needs. The protocol software must be open source to permit this.</li><li>Ownership and Participation  -  Users collectively own the protocols they use and have a say in how these will evolve in the future.</li></ul><p>An example of something that meets all of these points today is well governed blockchain protocol. Users retain control over their data in the sense that everything they submit is public and any user running a full node can observe the state of the ledger and submit transactions. The chain can be forked at any time and, if it demonstrates an advantage over the previous version, users can migrate to a new fork. If effective governance is in place then users could participate in governance to direct future developments in the protocol.&nbsp;</p><p>While this may meet web3 idealism, at the end of the day it only really offers a replacement to one tiny fraction of the current web - public peer-to-peer payments. There is still a long way to go.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="current-state-of-blockchain-gaming">Current state of blockchain gaming<a class="hash-link" href="#current-state-of-blockchain-gaming" title="Direct link to heading">​</a></h2><p>As it stands in 2022 the majority of blockchain games are using the technology for two main purposes:</p><ul><li>Feature gating based on token/NFT ownership</li><li>Rewarding users with tokens/NFTs</li></ul><p>In the  first case access to features, either cosmetic or relating to the gameplay itself, is gated. Unlocking these gates requires purchasing or otherwise obtaining a token. These are the micro-transaction and DLC models from modern games with ownership delegated to a blockchain layer. It does offer some advantages such as an open market and portability for tokens.</p><p>The second is the so called play-to-earn model which has its origins in the MMO gaming world. Players can engage in activities which consume time and/or require skill to produce in-game rewards. These rewards might form in-game economies and may themselves un-gate certain features. The blockchain forms the ledger for ownership of rewards and allows these to integrate with the external blockchain based economies.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="my-criticisms">My criticisms<a class="hash-link" href="#my-criticisms" title="Direct link to heading">​</a></h2><p>At this point I think it is pretty clear how these models are incompatible with web3 but lets go over them in detail.</p><p>If users truly have choice then many might chose to play a version of the game where unlocking features doesn't require purchasing anything at all. In fact I imagine all users would prefer to play this version of the game. The feature gating model requires games be both closed source and have some kind of DRM that takes this choice away from players and puts it in the hands of the game developers.</p><p>The second is even more insidious. User clients cannot interact with the blockchain directly to obtain rewards since they could modify their local copy to produce rewards with no effort. The game state needs to be globally agreed upon by all players but is far too complex to exist on the blockchain layer itself. The only solution is a server maintaining the state of players and deciding when rewards should be minted on the blockchain. In this case we have one centralized body deciding the rules of the game and retaining full control over the economy. This is how all play-to-earn games operate today. The users have no control, no choice and no ownership.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="is-there-any-hope-for-web3gaming">Is there any hope for web3&nbsp;gaming?<a class="hash-link" href="#is-there-any-hope-for-web3gaming" title="Direct link to heading">​</a></h2><p>The current trends of micro-transactions and play-to-earn are popular because they are potentially very profitable for the developers. But there is a whole class of games that have received very little attention at all: peer-to-peer games.</p><p>These have captivated humans for thousands of years and many types (e.g. trading card games, board games, gambling) are simple enough to implement directly on top of existing blockchain protocols.&nbsp;</p><p>Users retain choice because at the moment they decide to engage with another player they can collectively agree on the rules they wish to play with. Take for example a battle-style trading card game. If I am playing with a friend then we can decide that the game is more fun if a particular card is nerfed or the rules are tweaked in some other way. The company that printed the card has no say in the matter.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="in-conclusion">In Conclusion<a class="hash-link" href="#in-conclusion" title="Direct link to heading">​</a></h2><p>I'm a big fan of gaming and a believer in the virtues of technology based on web3 ideals. I would love to see some pioneers break out of the money-grabbing rut that the blockchain gaming world seems to be in at the moment and build something fun, novel and empowering. Shout out to Dark Forest (love your work).</p>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="gaming" term="gaming"/>
        <category label="tokenomics" term="tokenomics"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fairer Airdrops - An Investigation (Video)]]></title>
        <id>fair-airdrops</id>
        <link href="https://willemolding.github.io/blog/fair-airdrops"/>
        <updated>2021-12-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A talk from the annual ChainSafe Conference (CSCON) on how we could design better and more fair airdrops.]]></summary>
        <content type="html"><![CDATA[<p>A talk from the annual ChainSafe Conference (CSCON) on how we could design better and more fair airdrops.</p><iframe width="640" height="480" src="https://www.youtube.com/embed/V4KgcFYAX6U" title="CSCON1 Willem Olding - Fairer Airdrops: An Investigation" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="airdrops" term="airdrops"/>
        <category label="tokenomics" term="tokenomics"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intro to Polynomial Commitments (Video)]]></title>
        <id>polynomial-commitments</id>
        <link href="https://willemolding.github.io/blog/polynomial-commitments"/>
        <updated>2021-11-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A gentle introduction to polynomial commitments and some applications]]></summary>
        <content type="html"><![CDATA[<p>A gentle introduction to polynomial commitments and some applications</p><iframe width="640" height="480" src="https://www.youtube.com/embed/R47AIqaZHgs" title="Into to Polynomial Commitments" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="cryptography" term="cryptography"/>
        <category label="polynomial commitments" term="polynomial commitments"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fast Exits from Optimistic Rollups (Video)]]></title>
        <id>fast-exits</id>
        <link href="https://willemolding.github.io/blog/fast-exits"/>
        <updated>2021-03-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is my talk at the Toronto Ethereum Developers Meetup (EDMTo) on ways to avoid the challenge period delay (typically 7 days) when transferring tokens from an optimistic rollup to its host chain.]]></summary>
        <content type="html"><![CDATA[<p>This is my talk at the Toronto Ethereum Developers Meetup (EDMTo) on ways to avoid the challenge period delay (typically 7 days) when transferring tokens from an optimistic rollup to its host chain.</p><iframe width="640" height="480" src="https://www.youtube.com/embed/B0YdD_55ckM" title="Fast Exits from Optimistic Rollups - Willem Olding - [Toronto Ethereum Developers Meetup]" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe>]]></content>
        <author>
            <name>Willem Olding</name>
            <uri>https://github.com/willemolding</uri>
        </author>
        <category label="rollups" term="rollups"/>
    </entry>
</feed>