"use strict";(self.webpackChunkwillemolding_github_io=self.webpackChunkwillemolding_github_io||[]).push([[4269],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>m});var a=i(7294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,a,n=function(e,t){if(null==e)return{};var i,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var l=a.createContext({}),p=function(e){var t=a.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),h=p(i),m=n,d=h["".concat(l,".").concat(m)]||h[m]||u[m]||o;return i?a.createElement(d,s(s({ref:t},c),{},{components:i})):a.createElement(d,s({ref:t},c))}));function m(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=i.length,s=new Array(o);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:n,s[1]=r;for(var p=2;p<o;p++)s[p]=i[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,i)}h.displayName="MDXCreateElement"},5544:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=i(7462),n=(i(7294),i(3905));const o={slug:"dispute-games",title:"On-Chain Dispute Games - Past, Present and Future",authors:["willem"],tags:["l2","interoperability","game-theory","p2p"],keywords:["dispute","blockchain","optimism","arbitrum","l2","optimistic","scaling"],draft:!1,date:new Date("2023-09-21T00:00:00.000Z"),image:"https://solutions.chainsafe.io/img/post-thumbnail.png",description:"A short survey of different strategies of resolving disputes on-chain",hide_table_of_contents:!1},s=void 0,r={permalink:"/blog/dispute-games",source:"@site/blog/Dispute-Games.md",title:"On-Chain Dispute Games - Past, Present and Future",description:"A short survey of different strategies of resolving disputes on-chain",date:"2023-09-21T00:00:00.000Z",formattedDate:"September 21, 2023",tags:[{label:"l2",permalink:"/blog/tags/l-2"},{label:"interoperability",permalink:"/blog/tags/interoperability"},{label:"game-theory",permalink:"/blog/tags/game-theory"},{label:"p2p",permalink:"/blog/tags/p-2-p"}],readingTime:6.945,hasTruncateMarker:!1,authors:[{name:"Willem Olding",title:"Computer Systems Engineer, PhD",url:"https://github.com/willemolding",imageURL:"https://github.com/willemolding.png",key:"willem"}],frontMatter:{slug:"dispute-games",title:"On-Chain Dispute Games - Past, Present and Future",authors:["willem"],tags:["l2","interoperability","game-theory","p2p"],keywords:["dispute","blockchain","optimism","arbitrum","l2","optimistic","scaling"],draft:!1,date:"2023-09-21T00:00:00.000Z",image:"https://solutions.chainsafe.io/img/post-thumbnail.png",description:"A short survey of different strategies of resolving disputes on-chain",hide_table_of_contents:!1},nextItem:{title:"Some Attacks on Optimistic Systems",permalink:"/blog/attacks-permissionless-fraud"}},l={authorsImageUrls:[void 0]},p=[{value:"One-step Fraud Proving",id:"one-step-fraud-proving",level:2},{value:"2-party bisection dispute games",id:"2-party-bisection-dispute-games",level:2},{value:"Problems",id:"problems",level:3},{value:"Permissionless Bisection Dispute Games",id:"permissionless-bisection-dispute-games",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p};function u(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"One way to think of a blockchain is as a system for verifying provable statements to alter a global state. Examples of provable statements include:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Proving you hold a private key corresponding to a public key by signing some data. This is how transactions are authorized to mutate the ledger."),(0,n.kt)("li",{parentName:"ul"},"A proof-of-work (PoW)"),(0,n.kt)("li",{parentName:"ul"},"Proving you know the pre-image of a hash"),(0,n.kt)("li",{parentName:"ul"},"Proving result of executing a known, deterministic program on known data. The blockchain executes the program itself to check the result"),(0,n.kt)("li",{parentName:"ul"},"A SNARK proof of the result of executing a known program on (possibly unknown) data")),(0,n.kt)("p",null,"To verify a proof, the blockchain performs the verification computation inside its execution and this can result in changes to global state. Other on-chain applications can treat the result as if it is truth."),(0,n.kt)("p",null,"Some statements have a lovely property in that they are ",(0,n.kt)("em",{parentName:"p"},"succinct"),". This means it is easier to verify them than it is to prove them (PoW, SNARK). Others take the same amount of work either way (deterministic arbitrary computation). "),(0,n.kt)("p",null,"What you might have spotted from above is that some of these are in theory provable statements but they are impractical to prove on a blockchain. For example hashing an extremely large piece of data, or checking the result of a long and complex computation."),(0,n.kt)("p",null,"Dispute games are multi-party protocols that, under certain economic conditions, can allow a blockchain to be convinced of a statement while only having to execute a small part of a computation when disputes arise."),(0,n.kt)("h2",{id:"one-step-fraud-proving"},"One-step Fraud Proving"),(0,n.kt)("p",null,"For statements that could be proven on-chain there is an elegant solution that can avoid expensive verification costs. In a one-step fraud proof Ashley submits a statement on-chain (e.g. the result of this computation is X) along with a bond. The bond should be greater than the expected gas cost of having the chain verify the proof."),(0,n.kt)("p",null,"The statement is considered pending by the chain for a length of time known as the challenge period. During this time anyone (Bellamy) can pay the gas and force the chain to perform the check in full. This will then determine if Ashley was indeed correct and update the state accordingly. If Ashley is proven to be wrong their bond is slashed and given to Bellamy."),(0,n.kt)("p",null,"Importantly, if no one challenges Ashley during the challenge period it is safe to assume the statement is true under the assumption that there is at least one observer who would have proven Ashely false if they could."),(0,n.kt)("p",null,"This approach is great for on-going protocols like rollups where it is important to keep the running cost low. It is relatively simple in its implementation and can be permissionless. "),(0,n.kt)("p",null,"This design was used by the early versions of Optimism such that the rollup state transition was only computed on L1 in the case of a dispute. Another clever application is in the ",(0,n.kt)("a",{parentName:"p",href:"https://near.org/blog/eth-near-rainbow-bridge",title:"Eth-NEAR Rainbow Bridge"},"Eth-NEAR Rainbow Bridge")," where one-step fraud proofs are used to avoid performing expensive Ed25519 signature checks on Ethereum under regular operation. In recent months some projects such as ",(0,n.kt)("a",{parentName:"p",href:"https://fuel-labs.ghost.io/introducing-hybrid-proving/",title:"Fuel Labs - Hybrid proving"},"Fuel")," have proposed using on-step fraud proofs to avoid performing expensive SNARK verification unless there is a dispute."),(0,n.kt)("p",null,"The downside to one-step proofs is they are not applicable in every case. It must be possible to fall back to executing the verification on-chain. Some types of computation are simply too large or require too much data for this to be feasible. What can be done in this case?"),(0,n.kt)("h2",{id:"2-party-bisection-dispute-games"},"2-party bisection dispute games"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf",title:"Arbitrum: Scalable, private smart contracts"},"Arbitrum paper")," first popularized bisection dispute games in the blockchain space. To understand a bisection game you first need to understand emulators and the computation trace. "),(0,n.kt)("p",null,"A program can be expressed as a sequence of instructions to be executed on a processor. This processor also has registers and/or memory to store state."),(0,n.kt)("p",null,"Executing the program and recording the registers+memory at after each instruction is called an execution trace. This trace may be much longer than the original program as instructions may branch or loop. For a program that terminates this execution trace can be considered a very verbose proof of the final state. A program that knows how to execute all the possible instructions and update the state accordingly (an emulator) can verify this proof."),(0,n.kt)("p",null,"A program trace for any non-trivial program is absurdly huge, but it can be compressed using two clever tricks."),(0,n.kt)("p",null,"The first is that the full CPU+memory state need not be included at each step. Instead a commitment of the state (e.g. Merkle root) can be recorded instead."),(0,n.kt)("p",null,"The second applies when there are two conflicting parties in dispute about the result of executing a program. A two-party protocol can be used to reduce the trace down to the first instruction that the parties disagree upon the result of. A third trusted arbitrator (usually a blockchain runtime) can then execute only a single instruction in the trace resolve a dispute over an entire program."),(0,n.kt)("p",null,"This last trick of framing the dispute as being between two parties allows proving faults in programs in a number of steps that is logarithmic in the length of the trace, followed by the execution of a single instruction. This is incredibly powerful and has been developed by Arbitrum and the Optimism Bedrock prototype for proving rollup state transitions, along with Cartesi for proving arbitrary computations on-chain."),(0,n.kt)("h3",{id:"problems"},"Problems"),(0,n.kt)("p",null,"The problem with this approach as described is that once two players are engaged in a dispute they must both remain live in order to resolve it. There is also no way to ensure that both participants are honest so it must be possible for multiple disputes to be open on a single claim at once for the honest minority assumption to hold."),(0,n.kt)("p",null,"A malicious challenger may open many dispute games on a single assertion and although they will lose their bond if they have more available funds than the defender they can eventually prevent them from being able to participate. I have written about this issue in ",(0,n.kt)("a",{parentName:"p",href:"https://willemolding.github.io/blog/attacks-permissionless-fraud",title:"Some Attacks on Optimistic Systems"},"another article"),"."),(0,n.kt)("p",null,"The usual solution to this is to limit who can participate in dispute games. This is the approach used by Arbitrum and the Optimism Bedrock prototype. This compromise places these dispute game systems in an in-between trusted federation and fully permissionless dispute games."),(0,n.kt)("h2",{id:"permissionless-bisection-dispute-games"},"Permissionless Bisection Dispute Games"),(0,n.kt)("p",null,"So can bisection style dispute games be made fully permissionless? A recent ",(0,n.kt)("a",{parentName:"p",href:"https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf",title:"Arbitrum: Scalable, private smart contracts"},"paper by Nehab and Teixeira")," proposes a modification to the dispute games where the participants must submit a vector commitment to the entire execution trace before the game begins. Once this has been done the game becomes permissionless as anyone can submit a step along with its inclusion proof."),(0,n.kt)("p",null,"This is an excellent solution however it has a major drawback. Execution traces are incredibly large, commonly several trillion instructions. Producing a merkle tree and associated proofs for such a long vector is prohibitive in most cases. The authors solution to this is to split the trace into stages and run "),(0,n.kt)("p",null,"More recently Optimism has proposed ",(0,n.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=GaLm4iXOtOo&t=1392s&",title:"Keys in Mordor Summit: Dispute Games"},"another design")," which structures dispute game is structured as an n-degree tree rather than a binary tree. This allows other participants to fork off an existing dispute game when they believe participants to be fraudulent. "),(0,n.kt)("p",null,"Bond is added incrementally at each step of the tree allowing permissionless participation. Once a game has concluded the player who asserted correctly against any branch that has been proven false can collect the bond on each of those nodes in the tree."),(0,n.kt)("p",null,"This design gives the best of both worlds allowing permissionless participation without needing to compute trace commitments. This is at the cost of increased complexity in implementation."),(0,n.kt)("h2",{id:"conclusion"},"Conclusion"),(0,n.kt)("p",null,"Dispute games are conceptually simple but designing them to be permissionless is much more challenging. Despite dispute games being proposed for use in blockchain systems more than 5 years ago, and claiming to be permissionless, there has not been a single permissionless dispute game used in production."),(0,n.kt)("p",null,"Optimism has made excellent progress in the last year design dispute games that can be safe and permissionless and these will hopefully be deployed in production in the near future."))}u.isMDXComponent=!0}}]);